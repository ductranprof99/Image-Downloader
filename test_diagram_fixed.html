<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ImageDownloader Sequence Diagram - FIXED</title>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            securityLevel: 'loose',
            logLevel: 'info'
        });
    </script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-width: 100%;
            overflow-x: auto;
        }
        h1 {
            color: #333;
        }
        #status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
        }
        .success { background-color: #d4edda; color: #155724; }
        .error { background-color: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ImageDownloader Library - Complete Sequence Diagram (FIXED)</h1>
        <div id="status">Loading diagram...</div>
        <div class="mermaid">
sequenceDiagram
    actor User
    participant UI as UIImageView/SwiftUI
    participant Manager as ImageDownloaderManager
    participant Registry as CallerRegistry<br/>(WeakBox + NSLock)
    participant Cache as CacheAgent<br/>(Actor)
    participant Storage as StorageAgent<br/>(FileManager)
    participant Network as NetworkAgent<br/>(Serial Queue)
    participant Queue as PendingQueue<br/>(Priority FIFO)
    participant URLSession as URLSession<br/>(Background)
    participant Decoder as ImageDecoder<br/>(Background)

    User->>UI: Display Image
    UI->>Manager: requestImage(url, caller, latency, priority, completion)
    Note over Manager: Wrap completion to ensure<br/>main thread execution

    Manager->>Cache: await image(for: url)
    activate Cache

    alt Cache HIT
        Cache-->>Manager: .hit(UIImage)
        deactivate Cache
        Manager->>Storage: Check if storage has image
        alt Storage MISS (optional save)
            Manager->>Storage: saveImage(image, url)
            Note over Storage: Save on background thread<br/>with compression
        end
        Manager->>UI: completion(image, nil, fromCache: true, fromStorage: false)
        UI->>User: Display Image

    else Cache WAIT (Download in Progress)
        Cache-->>Manager: .wait
        Note over Manager: Another request is downloading<br/>same URL - join existing task
        Manager->>Registry: registerCaller(url, caller, completion, progress)
        activate Registry
        Registry-->>Registry: Store weak reference<br/>to avoid retain cycles
        deactivate Registry
        deactivate Cache
        Note over Manager,Registry: Will be notified when<br/>download completes

    else Cache MISS
        Cache-->>Manager: .miss
        Note over Cache: Creates placeholder entry<br/>to mark download in progress
        deactivate Cache

        alt Storage Enabled & HIT
            Manager->>Storage: image(for: url)
            activate Storage
            Storage-->>Manager: UIImage
            deactivate Storage
            Manager->>Cache: await setImage(image, url, isHighLatency)
            activate Cache
            Cache-->>Cache: Add to LRU queue<br/>(high or low latency)
            Cache-->>Manager: Success
            deactivate Cache
            Manager->>UI: completion(image, nil, fromCache: false, fromStorage: true)
            UI->>User: Display Image

        else Storage MISS or Disabled - Download from Network
            alt Storage Enabled
                Manager->>Storage: image(for: url)
                activate Storage
                Storage-->>Manager: nil
                deactivate Storage
            end

            Note over Manager: Download from Network Flow
            Manager->>Network: downloadData(url, priority, progress, completion)
        activate Network

        Network->>Network: isolationQueue.async
        Note over Network: Serial queue ensures<br/>thread-safe state access

        alt Request Deduplication - Already Downloading
            Network-->>Network: Check activeDownloads[url]
            Network-->>Network: Join existing DownloadTask
            Note over Network: Multiple requests for same URL<br/>share single network call
            Network-->>Manager: (Will notify via shared task)
            deactivate Network

        else Concurrency Limit Reached
            Network-->>Queue: Add to pendingQueue
            activate Queue
            Note over Queue: Insert based on priority:<br/>high priority jumps ahead
            deactivate Queue
            Network-->>Manager: (Queued, will start when slot available)
            deactivate Network

        else Slot Available - Start Download
            Network->>Network: Create DownloadTask
            Network->>Network: Add to activeDownloads
            Network->>URLSession: dataTask(with: request)
            activate URLSession

            Note over URLSession: Background thread download<br/>with progress callbacks

            URLSession-->>Network: Download progress updates
            Network->>UI: progress callback (main thread)
            UI->>User: Show progress

            alt Download Success
                URLSession-->>Network: Data received
                deactivate URLSession

                Network->>Decoder: decodeImage(from: data)
                activate Decoder
                Note over Decoder: Decode on background thread<br/>to avoid blocking main thread
                Decoder-->>Network: UIImage
                deactivate Decoder

                Network->>Network: Remove from activeDownloads
                Network->>Network: notifyAllWaiters(image, nil)
                Network->>Queue: processNextPendingUnsafe()
                activate Queue
                Queue-->>Queue: Pop next request<br/>from priority queue
                Queue->>Network: Start next download
                deactivate Queue

                Network-->>Manager: completion(image, nil)
                deactivate Network

                Note over Manager: Process Downloaded Image
                Manager->>Manager: processDownloadedImage()

                par Save to Storage (Background)
                    Manager->>Storage: saveImage(image, url)
                    activate Storage
                    Note over Storage: DispatchQueue.global()<br/>1. Create subdirectories<br/>2. Compress image<br/>3. Write to disk atomically
                    deactivate Storage
                and Update Cache (Actor)
                    Manager->>Cache: await setImage(image, url, isHighLatency)
                    activate Cache
                    Note over Cache: 1. Update cacheData[url]<br/>2. Append to LRU queue<br/>3. Evict if over limit
                    Cache-->>Cache: evictMemory(isHighLatency)
                    Note over Cache: Remove least recently used<br/>from front of queue
                    deactivate Cache
                end

                Manager->>Manager: notifySuccess(url, image)
                Manager->>UI: completion(image, nil, fromCache: false, fromStorage: false)
                Manager->>Registry: notifyCallers(url, image, nil, false, false)
                activate Registry
                Registry-->>Registry: Get all waiters for URL
                Registry-->>Registry: Filter alive callers (WeakBox)
                Registry-->>Registry: Remove URL from registry
                loop For each waiting caller
                    Registry->>UI: completion(image, nil, false, false)<br/>(main thread)
                    UI->>User: Display Image
                end
                deactivate Registry

            else Download Failed with Retry
                URLSession-->>Network: Error
                deactivate URLSession
                Network->>Network: Check RetryPolicy.shouldRetry()
                Note over Network: Exponential backoff:<br/>delay = baseDelay × 2^attempt
                Network->>Network: asyncAfter(delay)
                Network->>URLSession: Retry download
                activate URLSession
                Note over URLSession: Attempt download again<br/>up to maxAttempts
                URLSession-->>Network: ...
                deactivate URLSession

            else Download Failed - No Retry
                URLSession-->>Network: Error (final)
                deactivate URLSession
                Network->>Network: Remove from activeDownloads
                Network->>Network: notifyAllWaiters(nil, error)
                Network->>Queue: processNextPendingUnsafe()
                Network-->>Manager: completion(nil, error)
                deactivate Network

                Manager->>Manager: notifyFailure(url, error)
                Manager->>UI: completion(nil, error, false, false)
                Manager->>Registry: notifyCallers(url, nil, error, false, false)
                activate Registry
                loop For each waiting caller
                    Registry->>UI: completion(nil, error, false, false)
                    UI->>User: Show error state
                end
                deactivate Registry
            end
        end
        end
    end

    Note over Registry: Cleanup Timer (every 30s)
    Registry-->>Registry: cleanupDeadCallers()
    Note over Registry: Remove entries where<br/>caller.value == nil
        </div>
    </div>

    <script>
        window.addEventListener('load', () => {
            setTimeout(() => {
                const status = document.getElementById('status');
                const diagram = document.querySelector('.mermaid svg');
                if (diagram) {
                    status.textContent = '✓ Diagram rendered successfully!';
                    status.className = 'success';
                } else {
                    status.textContent = '✗ Diagram failed to render. Check console for errors.';
                    status.className = 'error';
                }
            }, 2000);
        });

        window.addEventListener('error', (e) => {
            const status = document.getElementById('status');
            status.textContent = '✗ Error: ' + e.message;
            status.className = 'error';
            console.error('Error details:', e);
        });
    </script>
</body>
</html>
